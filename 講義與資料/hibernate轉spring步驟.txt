1.先在 webapp/WEB-INF/web.xml 新增:
(讓 WEB 應用程式初始化時建立 Spring 的 IoC 容器 同時讀取組態資訊建立系統所需要的Bean)
<listener>  
  <listener-class>
  org.springframework.web.context.ContextLoaderListener
  </listener-class>
</listener>

(說明組態檔的位置)
<context-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>/WEB-INF/applicationContext.xml</param-value>  這是 SPRING 的掃瞄 (SERVICE , DAO)
</context-param>

(處理 Hibernate 在 WEB 環境中因 Lazy Loading 的問題,當頁面 response 時資料還沒讀取到
Java 物件,而導致 jsp 頁面讀不到 Hibernate 對應的資料)
<filter>
	<filter-name>OpenSessionViewFilter</filter-name>
	<filter-class>
	org.springframework.orm.hibernate5.support.OpenSessionInViewFilter
	</filter-class>
</filter>
<filter-mapping>
	<filter-name>OpenSessionViewFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>

2.在 webapp/WEB-INF/ 新增applicationContext.xml
<context:annotation-config />
<context:component-scan base-package="tw.hibernatedemo" />  (package改成專案的名字) 這是 HIBERNATE 的掃瞄 (@ENTITY)
<aop:aspectj-autoproxy/>

3.在 pom.xml 裡新增
連線池:HikariCP
Spring:spring-jdbc,spring-orm,spring-tx,spring-web
Hibernate:hibernate-core
Web:javax,servlet-api,jstl

<properties>(Spring的版本設定)
	<spring.version>5.3.24</spring.version>
</properties>

<dependencies>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>4.0.1</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>com.microsoft.sqlserver</groupId>
			<artifactId>mssql-jdbc</artifactId>
			<version>11.2.1.jre11</version>
		</dependency>

		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.6.14.Final</version>
		</dependency>
		
		<dependency> (連線池 HikariCP)
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>5.0.1</version>
		</dependency>
                 
                (Spring所有需要的)
                <dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-beans</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aop</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${spring.version}</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${spring.version}</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjweaver</artifactId>
			<version>1.9.8</version>
		</dependency>
		
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>1.9.8</version>
		</dependency>

		<dependency>
			<groupId>javax.annotation</groupId>
			<artifactId>javax.annotation-api</artifactId>
			<version>1.3.2</version>
		</dependency>

</dependencies>

4.由於 Spring 不需要Util來幫忙執行,所以刪除 Util 並且 DAO 及 Service 中不需要建構子額外 new 一個出來
所以刪除建構子,並在需要 spring 控管的 class 以及 物件上新增標籤 
EX:
在 SERVICE 中:
@Transactional
@Service
public class MemberService {

	@Autowired
	private MemberDao mDao;
	
在 DAO 中
@Repository
public class MemberDao{
   @Autowired
	private SessionFactory factory;

   public 發法(){
     .
     .
     .
   }
}

5.Spring 中不需要 hibernate.cfg.xml檔,而是在新增一個 config package 來做連線管理及掃瞄標籤
使用 @Configuration + @Bean 的方法創建 Bean

在 class 上新增 @Configuration 和 使用 spring 提供的交易管理機制 @EnableTransactionManagement
/config package/新增 AppConfig.java 的 class

@Configuration
@EnableTransactionManagement
public class AppConfig {
	
	
	@Bean   (spring 將 hibernate 的 SessionFactory 納入管理 在Spring容器內定義
                 LocalSessionFactoryBean 來取得 SessionFactory 由 packagesToScan 屬性定義掃描到哪個套件下的 Entity 類別)      
	public LocalSessionFactoryBean sessionFactory() {
		LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();
		sessionFactory.setDataSource(datasource());
		sessionFactory.setHibernateProperties(hibernateProperties());
		sessionFactory.setPackagesToScan("tw.hibernatedemo.model");
		return sessionFactory;
		
	}
	
	@Bean  (定義 HibernateTransactionManager 來控管交易)
	public HibernateTransactionManager transactionManager() {
		HibernateTransactionManager txManager = new HibernateTransactionManager();
		txManager.setSessionFactory(sessionFactory().getObject());
		return txManager;
	}
	
	
	public Properties hibernateProperties() {
		Properties properties = new Properties();
		properties.put("hibernate.dialect", "org.hibernate.dialect.SQLServer2016Dialect");
		properties.put("hibernate.show_sql", Boolean.TRUE);
		properties.put("hibernate.format_sql", Boolean.TRUE);
//		properties.put("hibernate.hbm2ddl.auto", "update"); (資料庫幫忙建表格)
		return properties;
	}
	
	
	public HikariDataSource datasource() { (資料庫連接設定)
		HikariConfig config = new HikariConfig();
		config.setJdbcUrl("jdbc:sqlserver://localhost:1433;databaseName=hibernate;trustServerCertificate=true");
		config.setUsername("sa");
		config.setPassword("sa123456");
		config.setDriverClassName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
		config.setMaximumPoolSize(5);
		config.setAutoCommit(false);交易給SPRING控管
		HikariDataSource ds = new HikariDataSource(config);
		return ds;
	}

}

6.在 Servlet package 中 Servlet 不需要 在 new service() 的方式呼叫 service
而是透過 
WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());
MemberService memberService = context.getBean("memberService",MemberService.class);